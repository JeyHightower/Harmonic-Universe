import{c as e}from"./vendor-redux-toolkit.fa18e013.js";import t from"./app-services-api.399edcf9.js";import{b as s}from"./app-redux-scene-slice.81f21730.js";const a=e=>{var t,s,a,n;return{message:(null==(s=null==(t=e.response)?void 0:t.data)?void 0:s.message)||e.message||"An error occurred",status:null==(a=e.response)?void 0:a.status,data:null==(n=e.response)?void 0:n.data}},n=e=>{if(!e)return null;return{...e,created_at:e.created_at?e.created_at.toString():null,updated_at:e.updated_at?e.updated_at.toString():null}},r=e=>e&&Array.isArray(e)?e.map(n):[],c=e("scenes/fetchScenes",(async(e,{rejectWithValue:s})=>{var a,n;try{const s=(new Date).toISOString();let o,l=[],u="";try{o=await t.getScenes(e),(null==(a=null==o?void 0:o.data)?void 0:a.scenes)&&(l=o.data.scenes,u="getScenes")}catch(r){try{o=await t.getUniverseScenes(e),(null==(n=null==o?void 0:o.data)?void 0:n.scenes)&&(l=o.data.scenes,u="getUniverseScenes")}catch(c){try{const t={Accept:"application/json","Content-Type":"application/json"},s=localStorage.getItem("token");s&&(t.Authorization=`Bearer ${s}`);const a=[`/api/scenes?universe_id=${e}`,`/api/scenes/universe/${e}`,`/api/universes/${e}/scenes`];let n=!1;for(const e of a){if(n)break;try{const s=await fetch(e,{method:"GET",headers:t,credentials:"include"});if(!s.ok)continue;const a=await s.json();Array.isArray(a)?(l=a,n=!0,u=`direct-fetch-array:${e}`):a.scenes&&Array.isArray(a.scenes)?(l=a.scenes,n=!0,u=`direct-fetch-scenes:${e}`):a.data&&Array.isArray(a.data)&&(l=a.data,n=!0,u=`direct-fetch-data:${e}`)}catch(d){}}if(!n)return{scenes:[],message:"Failed to get scenes from any endpoint",universe_id:e}}catch(i){return{scenes:[],message:"Failed to get scenes",universe_id:e}}}}return{scenes:l,message:"Scenes retrieved successfully",universe_id:e,_debug:{timestamp:s,endpoint:u}}}catch(o){return s(o.message)}})),d=c,i=e("scenes/fetchSceneById",(async(e,{rejectWithValue:s,getState:r})=>{var c;try{if(!e)throw new Error("Scene ID is required");const s=await t.getScene(e);if(!s.data||!s.data.scene)throw new Error("Invalid response format - missing scene data");const a=s.data.scene,r=n({...a,is_deleted:!1});return{message:(null==(c=s.data)?void 0:c.message)||"Scene fetched successfully",scene:r,status:s.status||200}}catch(d){return s(a(d))}})),o=e("scenes/createScene",(async(e,{dispatch:r,rejectWithValue:d,getState:i})=>{var o,l,u,y,_,f;try{const a={...e,is_deleted:!1};a.title&&!a.name&&(a.name=a.title,delete a.title),a.timeOfDay&&!a.time_of_day&&(a.time_of_day=a.timeOfDay,delete a.timeOfDay),a.characterIds&&!a.character_ids&&(a.character_ids=a.characterIds,delete a.characterIds),a.dateOfScene&&!a.date_of_scene&&(a.date_of_scene=a.dateOfScene,delete a.dateOfScene),a.notesText&&!a.notes_text&&(a.notes_text=a.notesText,delete a.notesText);const d=await t.createScene(a),_={id:(null==(l=null==(o=d.data)?void 0:o.scene)?void 0:l.id)||Date.now().toString(),name:a.name||"New Scene",description:a.description||"",universe_id:a.universe_id,scene_type:a.scene_type||"standard",is_active:!1!==a.is_active,created_at:(new Date).toISOString(),updated_at:(new Date).toISOString(),is_deleted:!1};let f=(null==(u=d.data)?void 0:u.scene)||d.data;f=f&&0!==Object.keys(f).length?{..._,...f,is_deleted:!1,universe_id:a.universe_id}:_;const v=n(f);if(r&&(r({type:"scenes/addScene",payload:v}),r(s(v)),r({type:"scenes/setCurrentScene",payload:v}),v.universe_id)){const e=i();r({type:"scenes/fetchScenes/fulfilled",payload:{scenes:[...e.scenes.universeScenes[v.universe_id]||[],v],universe_id:v.universe_id},meta:{arg:v.universe_id}}),r(c(v.universe_id))}return{message:(null==(y=d.data)?void 0:y.message)||"Scene created successfully",scene:v,status:d.status||200}}catch(v){return r&&r({type:"scenes/setError",payload:(null==(f=null==(_=v.response)?void 0:_.data)?void 0:f.message)||v.message}),d(a(v))}})),l=e("scenes/updateScene",(async(e,{dispatch:s,rejectWithValue:r,getState:d})=>{var i;try{if(!e||!e.id)throw new Error("Scene ID is required for updating a scene");const a={...e,is_deleted:!1};a.title&&!a.name&&(a.name=a.title,delete a.title),a.timeOfDay&&!a.time_of_day&&(a.time_of_day=a.timeOfDay,delete a.timeOfDay),a.characterIds&&!a.character_ids&&(a.character_ids=a.characterIds,delete a.characterIds),a.dateOfScene&&!a.date_of_scene&&(a.date_of_scene=a.dateOfScene,delete a.dateOfScene),a.notesText&&!a.notes_text&&(a.notes_text=a.notesText,delete a.notesText);const r=a.id,d={...a};delete d.id;const o=await t.updateScene(r,d);if(!o.data||!o.data.scene)throw new Error("Invalid response format - missing scene data");const l=o.data.scene,u=n({...l,is_deleted:!1});u.universe_id&&s(c(u.universe_id));return{message:(null==(i=o.data)?void 0:i.message)||"Scene updated successfully",scene:u,status:o.status||200}}catch(o){return r(a(o))}})),u=e("scenes/deleteScene",(async(e,{dispatch:s,rejectWithValue:n,getState:r})=>{var d,i;try{if(!e)throw new Error("Scene ID is required for deletion");let a=null;try{const t=r().scenes.scenes.find((t=>t.id===e));t&&(a=t.universe_id)}catch(o){}const n=await t.deleteScene(e),l=(null==(d=n.data)?void 0:d.id)||e;a&&s(c(a));return{message:(null==(i=n.data)?void 0:i.message)||"Scene deleted successfully",id:l,universe_id:a,status:n.status||200}}catch(l){return n(a(l))}})),y=e("scenes/reorderScenes",(async({universeId:e,sceneOrders:s},{rejectWithValue:n})=>{var c;try{const a=s.map((({id:e,order:s})=>t.updateScene(e,{order:s})));await Promise.all(a);const n=await t.getScenes(e);let d=[];return d=n&&n.data&&Array.isArray(n.data.scenes)?r(n.data.scenes):n&&Array.isArray(n.scenes)?r(n.scenes):n&&"object"==typeof n&&"success"===n.status?r((null==(c=n.data)?void 0:c.scenes)||[]):Array.isArray(n)?r(n):[],{...n,scenes:d}}catch(d){return n(a(d))}}));export{c as a,i as b,o as c,u as d,d as f,y as r,l as u};
