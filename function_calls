<invoke name="list_dir" explanation="Examining root directory structure">
<parameter name="relative_workspace_path">.</parameter>
</invoke>

<invoke name="list_dir" explanation="Examining frontend directory">
<parameter name="relative_workspace_path">frontend</parameter>
</invoke>

<invoke name="list_dir" explanation="Examining the backend directory structure">
<parameter name="relative_workspace_path">backend</parameter>
</invoke>

<invoke name="codebase_search" explanation="Looking for all schema definitions">
<parameter name="query">schema definition model class</parameter>
<parameter name="target_directories">["backend/app/models", "backend/app/schemas"]</parameter>
</invoke>

<invoke name="grep_search" explanation="Looking for all import statements to analyze usage">
<parameter name="query">^import|^from.*import</parameter>
</invoke>

<invoke name="edit_file" explanation="Creating a new consolidated test file structure">
<parameter name="target_file">frontend/tests/cypress/e2e/README.md</parameter>
<parameter name="instructions">I will create a README documenting the new test structure and organization</parameter>
<parameter name="code_edit"># Test Structure

## Core Features
- `auth.cy.js` - Authentication tests
- `profile.cy.js` - User profile and preferences tests
- `universe.cy.js` - Universe management and export/import tests
- `storyboard.cy.js` - Storyboard creation and management tests

## Social Features
- `social.cy.js` - Combined social features (notifications, sharing, collaboration)
- `search.cy.js` - Search, discovery, and recommendations

## UI/UX Features
- `accessibility.cy.js` - Accessibility and keyboard shortcuts
- `responsive.cy.js` - Mobile and responsive design tests
- `performance.cy.js` - Performance and optimization tests

## Test Organization Guidelines
1. Each test file should focus on a specific domain
2. Common setup and utilities should be in support files
3. Avoid duplicate test scenarios across files
4. Use consistent naming and structure

## Removed/Consolidated Files
- Merged `notifications.cy.js` into `social.cy.js`
- Merged `sharing.cy.js` into `social.cy.js`
- Merged `export-import.cy.js` into `universe.cy.js`
</parameter>
<parameter name="blocking">true</parameter>
</invoke>

<invoke name="edit_file" explanation="Creating a schema definition file">
<parameter name="target_file">backend/app/schemas/README.md</parameter>
<parameter name="instructions">I will create a README documenting the schema structure</parameter>
<parameter name="code_edit"># Schema Structure

## Core Schemas
- `UserSchema` - User profile and authentication
- `UniverseSchema` - Universe properties and settings
- `StoryboardSchema` - Storyboard and scene management

## Social Schemas
- `NotificationSchema` - User notifications
- `CollaborationSchema` - Sharing and real-time collaboration
- `ActivitySchema` - User activity tracking

## Feature Schemas
- `PreferencesSchema` - User preferences and accessibility settings
- `PerformanceSchema` - Performance metrics and optimization
- `SearchSchema` - Search and discovery settings

## Relationships
1. User -> Universes (one-to-many)
2. Universe -> Storyboards (one-to-many)
3. Universe -> Collaborators (many-to-many)
4. User -> Notifications (one-to-many)
5. User -> Activities (one-to-many)

## Removed/Consolidated Schemas
- Merged `SharingSchema` into `CollaborationSchema`
- Merged `ExportSchema` into `UniverseSchema`
- Merged `ImportSchema` into `UniverseSchema`
</parameter>
<parameter name="blocking">true</parameter>
</invoke>

<invoke name="edit_file" explanation="Creating consolidated social features test file">
<parameter name="target_file">frontend/tests/cypress/e2e/social.cy.js</parameter>
<parameter name="instructions">I will combine notifications, sharing, and collaboration tests into one file</parameter>
<parameter name="code_edit">describe('Social Features', () => {
  beforeEach(() => {
    // Mock login
    cy.intercept('POST', '/api/auth/login', {
      statusCode: 200,
      body: {
        user: { id: 1, username: 'testuser' },
        token: 'fake-jwt-token',
      },
    }).as('loginRequest');

    // Mock notifications
    cy.intercept('GET', '/api/notifications', {
      statusCode: 200,
      body: {
        notifications: [
          {
            id: 1,
            type: 'collaboration_invite',
            content: 'You have been invited to collaborate',
            sender: { id: 2, username: 'otheruser' },
            created_at: '2024-01-20T12:00:00Z',
            read: false,
          }
        ],
        unread_count: 1,
      },
    }).as('getNotifications');

    // Mock collaboration session
    cy.intercept('GET', '/api/universes/1/session', {
      statusCode: 200,
      body: {
        session_id: 'test-session',
        active_users: [
          {
            id: 1,
            username: 'testuser',
            cursor: { x: 100, y: 100 },
          }
        ],
      },
    }).as('getSession');

    cy.login();
  });

  describe('Notifications', () => {
    beforeEach(() => {
      cy.visit('/notifications');
      cy.wait('@getNotifications');
    });

    it('should display notifications', () => {
      cy.get('[data-testid="notifications-list"]').within(() => {
        cy.get('[data-testid="notification-1"]')
          .should('have.class', 'unread')
          .and('contain', 'collaborate');
      });
    });

    it('should mark notifications as read', () => {
      cy.intercept('POST', '/api/notifications/1/read', {
        statusCode: 200,
        body: { message: 'Marked as read' },
      }).as('markRead');

      cy.get('[data-testid="notification-1"]').click();
      cy.wait('@markRead');
      cy.get('[data-testid="notification-1"]').should('not.have.class', 'unread');
    });
  });

  describe('Collaboration', () => {
    beforeEach(() => {
      cy.visit('/universes/1/edit');
      cy.wait('@getSession');
    });

    it('should show active collaborators', () => {
      cy.get('[data-testid="active-users"]').should('contain', 'testuser');
    });

    it('should handle cursor tracking', () => {
      cy.window().then(win => {
        win.postMessage({
          type: 'cursor_update',
          data: { user_id: 2, cursor: { x: 200, y: 200 } },
        }, '*');
      });

      cy.get('[data-testid="remote-cursor-2"]').should(
        'have.css',
        'transform',
        'translate(200px, 200px)'
      );
    });
  });

  describe('Sharing', () => {
    beforeEach(() => {
      cy.visit('/universes/1/settings');
    });

    it('should manage collaborators', () => {
      cy.intercept('POST', '/api/universes/1/collaborators', {
        statusCode: 201,
        body: {
          id: 2,
          username: 'newcollaborator',
          role: 'editor',
        },
      }).as('addCollaborator');

      cy.get('[data-testid="add-collaborator"]').click();
      cy.get('[data-testid="collaborator-username"]').type('newcollaborator');
      cy.get('[data-testid="collaborator-role"]').select('editor');
      cy.get('[data-testid="submit-collaborator"]').click();

      cy.wait('@addCollaborator');
      cy.get('[data-testid="collaborator-2"]').should('contain', 'newcollaborator');
    });
  });

  describe('Error Handling', () => {
    it('should handle notification errors', () => {
      cy.intercept('GET', '/api/notifications', {
        statusCode: 500,
        body: { error: 'Failed to fetch notifications' },
      }).as('notificationError');

      cy.visit('/notifications');
      cy.wait('@notificationError');
      cy.get('[data-testid="error-message"]').should('contain', 'Failed to fetch notifications');
    });

    it('should handle collaboration errors', () => {
      cy.intercept('GET', '/api/universes/1/session', {
        statusCode: 500,
        body: { error: 'Failed to join session' },
      }).as('sessionError');

      cy.visit('/universes/1/edit');
      cy.wait('@sessionError');
      cy.get('[data-testid="error-message"]').should('contain', 'Failed to join session');
    });
  });
});</parameter>
<parameter name="blocking">true</parameter>
</invoke>

<invoke name="edit_file" explanation="Updating universe management tests to include export/import functionality">
<parameter name="target_file">frontend/tests/cypress/e2e/universe.cy.js</parameter>
<parameter name="instructions">I will combine universe management with export/import tests</parameter>
<parameter name="code_edit">describe('Universe Management', () => {
  beforeEach(() => {
    cy.intercept('POST', '/api/auth/login', {
      statusCode: 200,
      body: {
        user: { id: 1, username: 'testuser' },
        token: 'fake-jwt-token',
      },
    }).as('loginRequest');

    cy.intercept('GET', '/api/universes/1', {
      statusCode: 200,
      body: {
        id: 1,
        name: 'Test Universe',
        description: 'A test universe',
        physics_params: { particle_count: 1000 },
        audio_params: { sample_rate: 44100 },
      },
    }).as('getUniverse');

    cy.login();
  });

  describe('Basic Management', () => {
    it('should create universe', () => {
      cy.intercept('POST', '/api/universes', {
        statusCode: 201,
        body: {
          id: 2,
          name: 'New Universe',
        },
      }).as('createUniverse');

      cy.visit('/universes/new');
      cy.get('[data-testid="universe-name"]').type('New Universe');
      cy.get('[data-testid="create-universe"]').click();
      cy.wait('@createUniverse');
      cy.url().should('include', '/universes/2');
    });

    it('should edit universe', () => {
      cy.intercept('PUT', '/api/universes/1', {
        statusCode: 200,
        body: {
          id: 1,
          name: 'Updated Universe',
        },
      }).as('updateUniverse');

      cy.visit('/universes/1/edit');
      cy.get('[data-testid="universe-name"]').clear().type('Updated Universe');
      cy.get('[data-testid="save-universe"]').click();
      cy.wait('@updateUniverse');
      cy.get('[data-testid="success-message"]').should('be.visible');
    });
  });

  describe('Export', () => {
    beforeEach(() => {
      cy.visit('/universes/1/export');
    });

    it('should export as JSON', () => {
      cy.intercept('POST', '/api/universes/1/export', {
        statusCode: 200,
        body: {
          export_id: 'test-export',
          download_url: 'https://example.com/export.json',
        },
      }).as('exportUniverse');

      cy.get('[data-testid="format-json"]').click();
      cy.get('[data-testid="start-export"]').click();
      cy.wait('@exportUniverse');
      cy.get('[data-testid="download-export"]').should('be.visible');
    });
  });

  describe('Import', () => {
    it('should import universe', () => {
      cy.intercept('POST', '/api/universes/import', {
        statusCode: 200,
        body: {
          id: 3,
          name: 'Imported Universe',
        },
      }).as('importUniverse');

      cy.visit('/universes/import');
      cy.get('[data-testid="file-upload"]').attachFile('universe.json');
      cy.get('[data-testid="start-import"]').click();
      cy.wait('@importUniverse');
      cy.url().should('include', '/universes/3');
    });
  });

  describe('Error Handling', () => {
    it('should handle export errors', () => {
      cy.intercept('POST', '/api/universes/1/export', {
        statusCode: 500,
        body: { error: 'Export failed' },
      }).as('exportError');

      cy.visit('/universes/1/export');
      cy.get('[data-testid="start-export"]').click();
      cy.wait('@exportError');
      cy.get('[data-testid="error-message"]').should('contain', 'Export failed');
    });

    it('should handle import errors', () => {
      cy.intercept('POST', '/api/universes/import', {
        statusCode: 400,
        body: { error: 'Invalid file format' },
      }).as('importError');

      cy.visit('/universes/import');
      cy.get('[data-testid="file-upload"]').attachFile('invalid.json');
      cy.get('[data-testid="start-import"]').click();
      cy.wait('@importError');
      cy.get('[data-testid="error-message"]').should('contain', 'Invalid file format');
    });
  });
});</parameter>
<parameter name="blocking">true</parameter>
</invoke>

<invoke name="delete_file" explanation="Removing redundant notifications test file">
<parameter name="target_file">frontend/tests/cypress/e2e/social/notifications.cy.js</parameter>
</invoke>

<invoke name="delete_file" explanation="Removing redundant sharing test file">
<parameter name="target_file">frontend/tests/cypress/e2e/social/sharing.cy.js</parameter>
</invoke>

<invoke name="delete_file" explanation="Removing redundant export-import test file">
<parameter name="target_file">frontend/tests/cypress/e2e/features/export-import.cy.js</parameter>
</invoke>

<invoke name="edit_file" explanation="Creating main schema file">
<parameter name="target_file">backend/app/schemas/models.py</parameter>
<parameter name="instructions">I will create the main schema definitions file</parameter>
<parameter name="code_edit">from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field

class UserBase(BaseModel):
    username: str
    email: str

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

class UniverseBase(BaseModel):
    name: str
    description: Optional[str]
    physics_params: dict
    audio_params: dict

class Universe(UniverseBase):
    id: int
    owner_id: int
    created_at: datetime
    updated_at: datetime
    shared_with: List[int] = []

    class Config:
        orm_mode = True

class StoryboardBase(BaseModel):
    title: str
    description: Optional[str]
    scenes: List[dict]

class Storyboard(StoryboardBase):
    id: int
    universe_id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

class NotificationBase(BaseModel):
    type: str
    content: str
    recipient_id: int
    sender_id: Optional[int]

class Notification(NotificationBase):
    id: int
    created_at: datetime
    read: bool = False

    class Config:
        orm_mode = True

class CollaborationBase(BaseModel):
    universe_id: int
    user_id: int
    role: str = Field(default="viewer")

class Collaboration(CollaborationBase):
    id: int
    joined_at: datetime

    class Config:
        orm_mode = True

class ActivityBase(BaseModel):
    type: str
    user_id: int
    target_type: str
    target_id: int
    details: dict

class Activity(ActivityBase):
    id: int
    created_at: datetime

    class Config:
        orm_mode = True

class PreferencesBase(BaseModel):
    user_id: int
    theme: str = "light"
    notifications_enabled: bool = True
    accessibility: dict = Field(default_factory=dict)

class Preferences(PreferencesBase):
    id: int
    updated_at: datetime

    class Config:
        orm_mode = True

class PerformanceMetrics(BaseModel):
    universe_id: int
    fps: float
    memory_usage: float
    particle_count: int
    timestamp: datetime

# ... (rest of the code remains unchanged)

```
</parameter>
<parameter name="blocking">true</parameter>
</invoke>

<invoke name="edit_file" explanation="Creating migration documentation">
<parameter name="target_file">docs/migrations.md</parameter>
<parameter name="instructions">I will create the migration documentation</parameter>
<parameter name="code_edit"># Database Migrations

## Overview

This document describes the database migration process for the Harmonic Universe project. We use Alembic for database migrations.

## Migration Files

Current migrations in order:

1. `001_initial.py` - Initial schema setup
   - Users table
   - Universes table
   - Storyboards table
   - Base relationships

2. `002_notifications.py` - Notification system
   - Notifications table
   - Recipient/sender relationships
   - Indexes for efficient querying

3. `003_activities.py` - Activity tracking
   - Activities table
   - User activity relationships
   - Target type/id tracking

4. `004_performance_metrics.py` - Performance monitoring
   - Performance metrics table
   - Universe relationship
   - Timestamp-based indexing

5. `005_search_index.py` - Full-text search
   - Search index table
   - GIN index for search vector
   - Automatic vector updates

## Running Migrations

### Development Environment

```bash
# Apply all pending migrations
alembic upgrade head

# Rollback last migration
alembic downgrade -1

# Rollback to specific version
alembic downgrade <version_id>

# View migration history
alembic history
```

### Production Environment

```bash
# Apply migrations with verification
alembic upgrade head --sql > migration.sql
# Review migration.sql
psql -d your_database -f migration.sql
```

## Creating New Migrations

```bash
# Create new migration
alembic revision -m "description_of_changes"
```

### Migration Template

```python
"""description_of_changes

Revision ID: <auto_generated>
Revises: <previous_revision>
Create Date: <timestamp>

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '<auto_generated>'
down_revision = '<previous_revision>'
branch_labels = None
depends_on = None

def upgrade():
    # Add upgrade operations
    pass

def downgrade():
    # Add downgrade operations
    pass
```

## Best Practices

1. **Atomic Changes**
   - Each migration should be self-contained
   - Focus on related changes only
   - Include both upgrade and downgrade operations

2. **Idempotent Migrations**
   - Migrations should be idempotent
   - Running the same migration multiple times should have no effect

3. **Test Migrations**
   - Test migrations in a staging environment before applying to production
   - Verify data integrity and functionality

4. **Document Migrations**
   - Document changes in migration files
   - Include reasoning behind changes
   - Reference related issues or pull requests

5. **Review Migrations**
   - Review migrations with team members
   - Discuss potential impacts and risks
   - Ensure everyone is aligned with the changes

6. **Backup Data**
   - Always backup data before running migrations
   - Test restoring from backups if needed

7. **Rollback Plan**
   - Have a rollback plan in case of issues
   - Test rollback procedures regularly

8. **Version Control**
   - Use version control for migrations
   - Keep migrations in a separate branch
   - Merge migrations into main branch after testing

9. **Automation**
   - Automate migrations as much as possible
   - Use CI/CD pipelines for deployments

10. **Monitoring**
   - Monitor migrations for errors or failures
   - Set up alerts for migration failures

By following these best practices, we can ensure a smooth and reliable database migration process.
</parameter>
<parameter name="blocking">true</parameter>
</invoke>
